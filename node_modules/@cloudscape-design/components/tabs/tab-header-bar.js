// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import React, { useRef, useState, useEffect, forwardRef } from 'react';
import clsx from 'clsx';
import styles from './styles.css.js';
import { InternalButton } from '../button/internal';
import handleKey from '../internal/utils/handle-key';
import { KeyCode } from '../internal/keycode';
import { onPaginationClick, hasHorizontalOverflow, hasInlineStartOverflow, hasInlineEndOverflow, scrollIntoView, } from './scroll-utils';
import { hasModifierKeys, isPlainLeftClick } from '../internal/events';
import { useVisualRefresh } from '../internal/hooks/use-visual-mode';
import { useInternalI18n } from '../i18n/context';
import { useContainerQuery } from '@cloudscape-design/component-toolkit';
import { SingleTabStopNavigationProvider, useSingleTabStopNavigation, } from '../internal/context/single-tab-stop-navigation-context';
import { useMergeRefs } from '../internal/hooks/use-merge-refs';
import { getAllFocusables } from '../internal/components/focus-lock/utils';
const tabSelector = '[role="tab"]';
const activeTabSelector = '[role="tab"][aria-selected="true"]';
export function TabHeaderBar({ onChange, activeTabId, tabs, variant, idNamespace, ariaLabel, ariaLabelledby, i18nStrings, }) {
    const headerBarRef = useRef(null);
    const activeTabHeaderRef = useRef(null);
    const inlineStartOverflowButton = useRef(null);
    const i18n = useInternalI18n('tabs');
    const isVisualRefresh = useVisualRefresh();
    const containerObjectRef = useRef(null);
    const [widthChange, containerMeasureRef] = useContainerQuery(rect => rect.contentBoxWidth);
    const containerRef = useMergeRefs(containerObjectRef, containerMeasureRef);
    const tabRefs = useRef(new Map());
    const [horizontalOverflow, setHorizontalOverflow] = useState(false);
    const [inlineStartOverflow, setInlineStartOverflow] = useState(false);
    const [inlineEndOverflow, setInlineEndOverflow] = useState(false);
    useEffect(() => {
        if (headerBarRef.current) {
            setHorizontalOverflow(hasHorizontalOverflow(headerBarRef.current, inlineStartOverflowButton));
            setInlineStartOverflow(hasInlineStartOverflow(headerBarRef.current));
            setInlineEndOverflow(hasInlineEndOverflow(headerBarRef.current));
        }
    }, [widthChange, tabs]);
    const scrollIntoViewIfPossible = (smooth) => {
        if (!activeTabId) {
            return;
        }
        const activeTabRef = tabRefs.current.get(activeTabId);
        if (activeTabRef && activeTabRef.parentElement && headerBarRef.current) {
            scrollIntoView(activeTabRef.parentElement, headerBarRef.current, smooth);
        }
    };
    useEffect(() => {
        // Delay scrollIntoView as the position is depending on parent elements
        // (effects are called inside-out in the component tree).
        // Wait one frame to allow parents to complete it's calculation.
        requestAnimationFrame(() => {
            scrollIntoViewIfPossible(false);
        });
        // Non-smooth scrolling should not be called upon activeId change
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [horizontalOverflow, widthChange, tabs.length]);
    useEffect(() => {
        scrollIntoViewIfPossible(true);
        // Smooth scrolling should only be called upon activeId change
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [activeTabId]);
    useEffect(() => {
        var _a, _b;
        /*
         When the selected tab changes and we are currently already focused on a tab,
         move the focus to the newly selected tab.
        */
        if ((_a = headerBarRef.current) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement)) {
            if (document.activeElement !== activeTabHeaderRef.current) {
                (_b = activeTabHeaderRef.current) === null || _b === void 0 ? void 0 : _b.focus({ preventScroll: true });
            }
        }
    }, [activeTabId]);
    const onScroll = () => {
        if (headerBarRef.current) {
            setInlineStartOverflow(hasInlineStartOverflow(headerBarRef.current));
            setInlineEndOverflow(hasInlineEndOverflow(headerBarRef.current));
        }
    };
    const classes = clsx({
        [styles['tabs-header']]: true,
        [styles['tabs-header-with-divider']]: variant === 'default' || isVisualRefresh,
    });
    const leftButtonClasses = clsx({
        [styles['pagination-button']]: true,
        [styles['pagination-button-left']]: true,
        [styles['pagination-button-left-scrollable']]: inlineStartOverflow,
    });
    const rightButtonClasses = clsx({
        [styles['pagination-button']]: true,
        [styles['pagination-button-right']]: true,
        [styles['pagination-button-right-scrollable']]: inlineEndOverflow,
    });
    const navigationAPI = useRef(null);
    function getNextFocusTarget() {
        var _a, _b;
        if (!containerObjectRef.current) {
            return null;
        }
        const tabElements = Array.from(containerObjectRef.current.querySelectorAll(tabSelector));
        return (_b = (_a = tabElements.find(tab => tab.matches(activeTabSelector))) !== null && _a !== void 0 ? _a : tabElements.find(tab => !tab.disabled)) !== null && _b !== void 0 ? _b : null;
    }
    useEffect(() => {
        var _a;
        (_a = navigationAPI.current) === null || _a === void 0 ? void 0 : _a.updateFocusTarget();
    });
    function onFocus() {
        var _a;
        (_a = navigationAPI.current) === null || _a === void 0 ? void 0 : _a.updateFocusTarget();
    }
    function onBlur() {
        var _a;
        (_a = navigationAPI.current) === null || _a === void 0 ? void 0 : _a.updateFocusTarget();
    }
    function onKeyDown(event) {
        var _a;
        const focusTarget = (_a = navigationAPI.current) === null || _a === void 0 ? void 0 : _a.getFocusTarget();
        const specialKeys = [KeyCode.right, KeyCode.left, KeyCode.end, KeyCode.home, KeyCode.pageUp, KeyCode.pageDown];
        if (hasModifierKeys(event) || specialKeys.indexOf(event.keyCode) === -1) {
            return;
        }
        if (!containerObjectRef.current || !focusTarget) {
            return;
        }
        event.preventDefault();
        const focusables = getFocusablesFrom(containerObjectRef.current);
        const activeIndex = focusables.indexOf(focusTarget);
        handleKey(event, {
            onHome: () => focusElement(focusables[0]),
            onEnd: () => focusElement(focusables[focusables.length - 1]),
            onInlineStart: () => focusElement(focusables[circleIndex(activeIndex - 1, [0, focusables.length - 1])]),
            onInlineEnd: () => focusElement(focusables[circleIndex(activeIndex + 1, [0, focusables.length - 1])]),
            onPageDown: () => inlineEndOverflow && onPaginationClick(headerBarRef, 'forward'),
            onPageUp: () => inlineStartOverflow && onPaginationClick(headerBarRef, 'backward'),
        });
    }
    function focusElement(element) {
        var _a;
        element.focus();
        // If focusable element is a tab - fire the onChange for it.
        const tabsById = tabs.reduce((map, tab) => map.set(tab.id, tab), new Map());
        for (const [tabId, tabTriggerElement] of tabRefs.current.entries()) {
            if (tabId !== activeTabId && tabTriggerElement === element) {
                onChange({ activeTabId: tabId, activeTabHref: (_a = tabsById.get(tabId)) === null || _a === void 0 ? void 0 : _a.href });
                break;
            }
        }
    }
    // List all non-disabled and registered focusables: those are eligible for keyboard navigation.
    function getFocusablesFrom(target) {
        function isElementRegistered(element) {
            var _a, _b;
            return (_b = (_a = navigationAPI.current) === null || _a === void 0 ? void 0 : _a.isRegistered(element)) !== null && _b !== void 0 ? _b : false;
        }
        function isElementDisabled(element) {
            if (element instanceof HTMLButtonElement) {
                return element.disabled && element.getAttribute('aria-selected') !== 'true';
            }
            return false;
        }
        return getAllFocusables(target).filter(el => isElementRegistered(el) && !isElementDisabled(el));
    }
    return (
    //converted span to div as list should not be a child of span for HTML validation
    React.createElement("div", { className: classes, ref: containerRef },
        horizontalOverflow && (React.createElement("span", { ref: inlineStartOverflowButton, className: leftButtonClasses },
            React.createElement(InternalButton, { formAction: "none", variant: "icon", iconName: "angle-left", disabled: !inlineStartOverflow, __focusable: true, onClick: () => onPaginationClick(headerBarRef, 'backward'), ariaLabel: i18n('i18nStrings.scrollLeftAriaLabel', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.scrollLeftAriaLabel) }))),
        React.createElement(SingleTabStopNavigationProvider, { ref: navigationAPI, navigationActive: true, getNextFocusTarget: getNextFocusTarget },
            React.createElement("ul", { role: "tablist", className: styles['tabs-header-list'], "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby, ref: headerBarRef, onScroll: onScroll, onKeyDown: onKeyDown, onFocus: onFocus, onBlur: onBlur }, tabs.map(renderTabHeader))),
        horizontalOverflow && (React.createElement("span", { className: rightButtonClasses },
            React.createElement(InternalButton, { formAction: "none", variant: "icon", iconName: "angle-right", disabled: !inlineEndOverflow, __focusable: true, onClick: () => onPaginationClick(headerBarRef, 'forward'), ariaLabel: i18n('i18nStrings.scrollRightAriaLabel', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.scrollRightAriaLabel) })))));
    function renderTabHeader(tab) {
        const clickTab = (event) => {
            if (tab.disabled) {
                event.preventDefault();
                return;
            }
            // if the primary mouse button is clicked with a modifier key, the browser will handle opening a new tab
            const specialKey = !isPlainLeftClick(event);
            if (specialKey && tab.href) {
                return;
            }
            event.preventDefault();
            // for browsers that do not focus buttons on button click
            if (!tab.href) {
                const clickedTabRef = tabRefs.current.get(tab.id);
                if (clickedTabRef) {
                    if (clickedTabRef && clickedTabRef !== document.activeElement) {
                        clickedTabRef.focus({ preventScroll: true });
                    }
                }
            }
            if (tab.id === activeTabId) {
                return;
            }
            onChange({ activeTabId: tab.id, activeTabHref: tab.href });
        };
        const classes = clsx({
            [styles['tabs-tab-link']]: true,
            [styles.refresh]: isVisualRefresh,
            [styles['tabs-tab-active']]: activeTabId === tab.id && !tab.disabled,
            [styles['tabs-tab-disabled']]: tab.disabled,
        });
        const commonProps = {
            className: classes,
            role: 'tab',
            'aria-selected': tab.id === activeTabId,
            'aria-controls': `${idNamespace}-${tab.id}-panel`,
            'data-testid': tab.id,
            id: getTabElementId({ namespace: idNamespace, tabId: tab.id }),
            children: React.createElement("span", { className: styles['tabs-tab-label'] }, tab.label),
        };
        if (tab.disabled) {
            commonProps['aria-disabled'] = 'true';
        }
        else {
            commonProps.onClick = clickTab;
        }
        const setElement = (tabElement) => {
            if (tab.id === activeTabId) {
                activeTabHeaderRef.current = tabElement;
            }
            tabRefs.current.set(tab.id, tabElement);
        };
        return (React.createElement("li", { className: styles['tabs-tab'], role: "presentation", key: tab.id },
            React.createElement(TabTrigger, { ref: setElement, tab: tab, elementProps: commonProps })));
    }
}
const TabTrigger = forwardRef(({ tab, elementProps, }, ref) => {
    const refObject = useRef(null);
    const mergedRef = useMergeRefs(refObject, ref);
    const { tabIndex } = useSingleTabStopNavigation(refObject);
    return tab.href ? (React.createElement("a", Object.assign({}, elementProps, { href: tab.href, ref: mergedRef, tabIndex: tabIndex }))) : (React.createElement("button", Object.assign({}, elementProps, { type: "button", disabled: tab.disabled, ref: mergedRef, tabIndex: tabIndex })));
});
export function getTabElementId({ namespace, tabId }) {
    return namespace + '-' + tabId;
}
function circleIndex(index, [from, to]) {
    if (index < from) {
        return to;
    }
    if (index > to) {
        return from;
    }
    return index;
}
//# sourceMappingURL=tab-header-bar.js.map